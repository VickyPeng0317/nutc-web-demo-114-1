<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æŸ´æŸ´ CSV è§£æå·¥å» </title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    
    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- Google Fonts: Zen Maru Gothic for cuteness -->
    <link href="https://fonts.googleapis.com/css2?family=Zen+Maru+Gothic:wght@400;700&family=Noto+Sans+TC:wght@400;700&family=Roboto+Mono:wght@400;700&display=swap" rel="stylesheet">

    <style>
        body {
            font-family: 'Zen Maru Gothic', 'Noto Sans TC', sans-serif;
            overflow: hidden; /* Prevent scrolling on body */
            background-color: #fff8e1;
        }
        code, pre, .font-mono {
            font-family: 'Roboto Mono', monospace;
        }
        /* Custom scrollbar for cute theme */
        ::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }
        ::-webkit-scrollbar-track {
            background: #fff8e1; 
        }
        ::-webkit-scrollbar-thumb {
            background: #e6b422; /* Shiba Orange */
            border-radius: 10px;
            border: 2px solid #fff8e1;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #d98e4d; 
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useMemo } = React;

        // --- Icons (Custom Shiba Themed SVGs) ---
        const PawIcon = ({ size = 24, className = "" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="currentColor" className={className}>
                <path d="M12 2C13.2426 2 14.25 3.00736 14.25 4.25C14.25 5.49264 13.2426 6.5 12 6.5C10.7574 6.5 9.75 5.49264 9.75 4.25C9.75 3.00736 10.7574 2 12 2ZM17.5 3.5C18.7426 3.5 19.75 4.50736 19.75 5.75C19.75 6.99264 18.7426 8 17.5 8C16.2574 8 15.25 6.99264 15.25 5.75C15.25 4.50736 16.2574 3.5 17.5 3.5ZM6.5 3.5C7.74264 3.5 8.75 4.50736 8.75 5.75C8.75 6.99264 7.74264 8 6.5 8C5.25736 8 4.25 6.99264 4.25 5.75C4.25 4.50736 5.25736 3.5 6.5 3.5ZM12 8C15.5 8 18.5 10.5 18.5 14.5C18.5 18 16 21.5 12 21.5C8 21.5 5.5 18 5.5 14.5C5.5 10.5 8.5 8 12 8Z"/>
            </svg>
        );

        const BoneIcon = ({ size = 24, className = "" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <path d="M17 10c.7-.7 1.69 0 2.5 0a2.5 2.5 0 1 0 0-5 .5.5 0 0 1-.5-.5 2.5 2.5 0 1 0-5 0c0 .81.7 1.8 0 2.5l-7 7c-.7.7-1.69 0-2.5 0a2.5 2.5 0 0 0 0 5c.28 0 .5.22.5.5a2.5 2.5 0 1 0 5 0c0-.81-.7-1.8 0-2.5l7-7Z"/>
            </svg>
        );

        const RotateCcw = ({ size = 24, className = "" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 12"/><path d="M3 3v9h9"/></svg>
        );
        const ChevronRight = ({ size = 24, className = "" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="3" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="m9 18 6-6-6-6"/></svg>
        );
        const ChevronLeft = ({ size = 24, className = "" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="3" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="m15 18-6-6 6-6"/></svg>
        );

        // --- 1. Constants & Data ---

        const RAW_CSV = `æ™‚é–“æˆ³è¨˜,å§“å,å­¸è™Ÿ,Email,å¹´ç´š,é£²é£Ÿç¿’æ…£,å‚™è¨»
2025/12/18 11:16,Vic,1710932013,cxz...97@gmail,å¤§ä¸€,è‘·é£Ÿ,hi
2025/12/18 12:19,vic,10430004,xxxxx,å¤§å››,ä¸åƒç‰›,
2025/12/18 12:24,test,test,test,å¤§å››,ä¸åƒç‰›,`;

        const CODE_SNIPPET = `function csvToJson(csvText) {
  // 1. æ±ªï¼ç”¨æ›è¡Œç¬¦è™Ÿåˆ‡åˆ†å‡ºæ¯ä¸€è¡Œ
  const lines = csvText.split("\\n");

  // 2. å–å‡ºç¬¬ä¸€è¡Œç•¶ä½œã€Œæ¨™é¡Œã€(Headers)
  const headers = lines[0].split(",");

  const result = [];

  // 3. å¾ç¬¬äºŒè¡Œé–‹å§‹å·¡è¦½è³‡æ–™
  for (let i = 1; i < lines.length; i++) {
    // è™•ç†é˜²å‘†ï¼šè·³éç©ºè¡Œ
    if (!lines[i]) continue;

    const currentLine = lines[i].split(",");
    const obj = {};

    // 4. æŠŠæ¯å€‹æ¬„ä½å¡é€²ç‰©ä»¶è£¡
    for (let j = 0; j < headers.length; j++) {
       // headers[j] æ˜¯æ¬„ä½åç¨±
       // currentLine[j] æ˜¯å…§å®¹
       obj[headers[j].trim()] = currentLine[j].trim();
    }
    result.push(obj);
  }
  return result; // å®Œæˆï¼å¥½åƒçš„ç‰©ä»¶é™£åˆ—
}`;

        const STEPS = [
          {
            id: 0,
            title: "åˆå§‹ç‹€æ…‹",
            desc: "é€™æ˜¯å‰›é‹ä¾†çš„åŸå§‹ CSV é£Ÿæï¼Œé‚„æ˜¯ä¸€æ•´å¡Šæ²’åˆ‡é–‹çš„å­—ä¸²å–”ï¼",
            highlight: [],
            animationType: "raw"
          },
          {
            id: 1,
            title: "åˆ‡åˆ†è¡Œ (Split Lines)",
            desc: "æŸ´æŸ´ä½¿ç”¨ split('\\n') åˆ€æ³•ï¼ŒæŠŠæ•´å¡Šé£Ÿæåˆ‡æˆä¸€æ¢ä¸€æ¢çš„ã€‚",
            highlight: [2, 3],
            animationType: "split_lines"
          },
          {
            id: 2,
            title: "æå–æ¨™é¡Œ (Parse Headers)",
            desc: "å–å‡ºç¬¬ä¸€æ¢ (lines[0]) ç•¶ä½œæ¨™ç±¤ï¼Œé€™äº›æœƒè®Šæˆæˆ‘å€‘ JSON çš„ Key å–”ã€‚",
            highlight: [5, 6],
            animationType: "parse_headers"
          },
          {
            id: 3,
            title: "æº–å‚™ä¾¿ç•¶ç›’èˆ‡è¿´åœˆ",
            desc: "æº–å‚™å¥½ result ä¾¿ç•¶ç›’ï¼Œæº–å‚™å¾ç¬¬äºŒè¡Œé–‹å§‹è£½ä½œç¾å‘³çš„è³‡æ–™ã€‚",
            highlight: [8, 11],
            animationType: "init_loop"
          },
          {
            id: 4,
            title: "è™•ç†ç¬¬ä¸€ç­†è³‡æ–™ï¼šåˆ‡åˆ†",
            desc: "è®€å– lines[1]ï¼Œä½¿ç”¨ split(',') æŠŠé€™è¡Œåˆ‡æˆä¸€å¡Šå¡Šçš„å°é¤…ä¹¾ã€‚",
            highlight: [15],
            animationType: "process_row_1_split"
          },
          {
            id: 5,
            title: "è™•ç†ç¬¬ä¸€ç­†è³‡æ–™ï¼šçµ„è£ (Mapping)",
            desc: "æŠŠæ¨™ç±¤ (Key) è·Ÿé¤…ä¹¾ (Value) é…å°èµ·ä¾†ï¼Œçµ„è£æˆå¥½åƒçš„ç‰©ä»¶ (Object)ï¼",
            highlight: [18, 19, 20, 21, 22],
            animationType: "process_row_1_map"
          },
          {
            id: 6,
            title: "å­˜å…¥ä¾¿ç•¶ç›’",
            desc: "æŠŠçµ„è£å¥½çš„ç‰©ä»¶ (Object) å°å¿ƒåœ°æ”¾é€² result ä¾¿ç•¶ç›’è£¡ã€‚",
            highlight: [24],
            animationType: "process_row_1_push"
          },
          {
            id: 7,
            title: "è™•ç†ä¸‹ä¸€ç­†è³‡æ–™",
            desc: "ç¹¼çºŒåŠªåŠ›ï¼è™•ç†ä¸‹ä¸€è¡Œ lines[2]...",
            highlight: [11, 15],
            animationType: "process_row_2_split"
          },
          {
            id: 8,
            title: "å¤§åŠŸå‘Šæˆ",
            desc: "æ‰€æœ‰è³‡æ–™éƒ½è™•ç†å¥½äº†ï¼ŒJSON ä¾¿ç•¶è£½ä½œå®Œæˆï¼æ±ªï¼",
            highlight: [26],
            animationType: "finish"
          }
        ];

        // --- 2. Helper Functions ---
        const lerp = (start, end, t) => start * (1 - t) + end * t;
        const easeOutCubic = (t) => 1 - Math.pow(1 - t, 3);
        const easeInOutQuad = (t) => t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;

        // --- 3. Main Component ---
        function CSVVisualizer() {
            const [currentStep, setCurrentStep] = useState(0);
            const canvasRef = useRef(null);
            const containerRef = useRef(null);
            
            // å‹•ç•«ç›¸é—œç‹€æ…‹
            const requestRef = useRef();
            const startTimeRef = useRef();
            const [canvasSize, setCanvasSize] = useState({ width: 800, height: 600 });

            // é è™•ç†è³‡æ–™çµæ§‹ä»¥ä¾¿ç¹ªåœ–
            const processedData = useMemo(() => {
                const lines = RAW_CSV.split('\n');
                const headers = lines[0].split(',');
                const rows = lines.slice(1).map(line => line.split(','));
                return { lines, headers, rows };
            }, []);

            // RWD Canvas Resize
            useEffect(() => {
                const handleResize = () => {
                if (containerRef.current) {
                    const { clientWidth, clientHeight } = containerRef.current;
                    setCanvasSize({ width: clientWidth, height: clientHeight });
                }
                };
                window.addEventListener('resize', handleResize);
                handleResize(); // Initial resize
                return () => window.removeEventListener('resize', handleResize);
            }, []);

            // --- Animation Engine ---
            const animate = (time) => {
                if (!startTimeRef.current) startTimeRef.current = time;
                const progress = Math.min((time - startTimeRef.current) / 1000, 1); // 1ç§’å‹•ç•«
                const easedProgress = easeInOutQuad(progress);

                renderCanvas(currentStep, easedProgress);

                if (progress < 1) {
                requestRef.current = requestAnimationFrame(animate);
                }
            };

            useEffect(() => {
                startTimeRef.current = null;
                requestRef.current = requestAnimationFrame(animate);
                return () => cancelAnimationFrame(requestRef.current);
            }, [currentStep, canvasSize]);

            // --- Rendering Logic ---
            const renderCanvas = (stepIndex, t) => {
                const canvas = canvasRef.current;
                if (!canvas) return;
                const ctx = canvas.getContext('2d');
                const { width, height } = canvasSize;
                const stepType = STEPS[stepIndex].animationType;

                // --- Shiba Theme Colors ---
                const colors = {
                    bg: '#fff8e1',       // Cream background
                    raw: '#5d4037',      // Dark Brown
                    header: '#42a5f5',   // Soft Blue
                    data: '#66bb6a',     // Soft Green
                    accent: '#ffa726',   // Orange
                    textMain: '#3e2723', // Very dark brown
                    textLight: '#ffffff',
                    grid: '#f0e3ca'      // Latte
                };

                // Clear
                ctx.clearRect(0, 0, width, height);
                ctx.fillStyle = colors.bg;
                ctx.fillRect(0, 0, width, height);
                
                // Config
                const startX = 40;
                const startY = 50;
                const lineHeight = 40; // Taller for roundness
                const boxGap = 12;
                const resultBoxWidth = 320;
                const workingAreaWidth = width - resultBoxWidth - 60;
                const blockWidth = Math.min((workingAreaWidth / 7) - boxGap, 130); 

                // --- Helper: Draw JSON Object Text ---
                const drawJSONObject = (x, y, dataObj, headers, alpha = 1, scale = 1) => {
                    ctx.save();
                    ctx.globalAlpha = alpha;
                    ctx.translate(x, y);
                    ctx.scale(scale, scale);
                    
                    ctx.font = 'bold 15px "Roboto Mono", monospace';
                    ctx.textAlign = 'left';
                    ctx.textBaseline = 'top';

                    const lineHeight = 20;
                    let currentY = 0;

                    // Draw Opening Brace
                    ctx.fillStyle = '#795548'; // Brown
                    ctx.fillText('{', 0, currentY);
                    currentY += lineHeight;

                    // Draw Key-Values
                    headers.forEach((h, i) => {
                        if (i > 3) return; 
                        
                        const key = h.trim();
                        const val = dataObj[i] ? dataObj[i].trim() : "";

                        const indent = 20;
                        
                        // Key
                        ctx.fillStyle = '#ef6c00'; // Orange darken
                        ctx.fillText(`"${key}"`, indent, currentY);
                        const keyWidth = ctx.measureText(`"${key}"`).width;
                        
                        // Colon
                        ctx.fillStyle = '#9e9e9e'; 
                        ctx.fillText(`: `, indent + keyWidth, currentY);
                        const colonWidth = ctx.measureText(`: `).width;

                        // Value
                        ctx.fillStyle = '#2e7d32'; // Green darken
                        ctx.fillText(`"${val}"`, indent + keyWidth + colonWidth, currentY);
                        
                        // Comma
                        if (i < Math.min(headers.length, 4) - 1) {
                             const totalWidth = indent + keyWidth + colonWidth + ctx.measureText(`"${val}"`).width;
                             ctx.fillStyle = '#bdbdbd';
                             ctx.fillText(`,`, totalWidth, currentY);
                        }
                        
                        currentY += lineHeight;
                    });

                    if (headers.length > 4) {
                        ctx.fillStyle = '#bdbdbd';
                        ctx.fillText(`  ...`, 0, currentY);
                        currentY += lineHeight;
                    }

                    ctx.fillStyle = '#795548';
                    ctx.fillText('},', 0, currentY);
                    
                    ctx.restore();
                    return currentY + lineHeight;
                };

                // --- Helper: Draw Block (Cute Version) ---
                const drawBlock = (text, x, y, w, h, color, alpha = 1, borderColor = null, fontSize = 13) => {
                    ctx.save();
                    ctx.globalAlpha = alpha;
                    ctx.fillStyle = color;
                    
                    // Cute Shadow
                    ctx.shadowColor = 'rgba(93, 64, 55, 0.2)'; // Brownish shadow
                    ctx.shadowBlur = 6;
                    ctx.shadowOffsetY = 3;

                    ctx.beginPath();
                    if (ctx.roundRect) {
                        ctx.roundRect(x, y, w, h, 12); // Rounder corners
                    } else {
                        ctx.rect(x, y, w, h);
                    }
                    ctx.fill();
                    
                    ctx.shadowColor = 'transparent';

                    if (borderColor) {
                        ctx.strokeStyle = borderColor;
                        ctx.lineWidth = 3;
                        ctx.stroke();
                    }

                    ctx.fillStyle = '#ffffff';
                    ctx.font = `bold ${fontSize}px "Zen Maru Gothic", sans-serif`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    
                    let displayText = text;
                    const metrics = ctx.measureText(text);
                    if (metrics.width > w - 10) {
                        const avgCharWidth = metrics.width / text.length;
                        const maxChars = Math.floor((w - 20) / avgCharWidth);
                        displayText = text.substring(0, maxChars) + '..';
                    }
                    
                    ctx.fillText(displayText, x + w / 2, y + h / 2 + 1); // +1 for visual center
                    ctx.globalAlpha = 1;
                    ctx.restore();
                };

                // Helper: Draw Container (Cute Dash)
                const drawContainer = (x, y, w, h, label) => {
                    ctx.save();
                    ctx.strokeStyle = '#d7ccc8'; // Light brown
                    ctx.lineWidth = 3;
                    ctx.setLineDash([10, 10]);
                    
                    ctx.beginPath();
                    if (ctx.roundRect) {
                        ctx.roundRect(x, y, w, h, 16);
                    } else {
                        ctx.rect(x, y, w, h);
                    }
                    ctx.stroke();
                    
                    ctx.setLineDash([]);
                    
                    // Label Tag
                    const labelW = 160;
                    ctx.fillStyle = '#8d6e63'; // Brown tag
                    ctx.beginPath();
                    if (ctx.roundRect) {
                        ctx.roundRect(x + 10, y - 15, labelW, 30, 15);
                    } else {
                        ctx.rect(x + 10, y - 15, labelW, 30);
                    }
                    ctx.fill();

                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 14px "Zen Maru Gothic", sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(label, x + 10 + labelW/2, y);
                    ctx.restore();
                };

                const { lines, headers, rows } = processedData;

                // --- Scene Logic ---

                // 1. Scene: Raw Text Block
                if (stepType === 'raw') {
                    const boxH = lines.length * lineHeight + 50;
                    
                    // Paper style background
                    ctx.fillStyle = '#fff3e0'; // Orange-ish paper
                    ctx.beginPath();
                    if (ctx.roundRect) {
                        ctx.roundRect(startX, startY, workingAreaWidth, boxH, 10);
                    } else {
                        ctx.rect(startX, startY, workingAreaWidth, boxH);
                    }
                    ctx.fill();
                    ctx.strokeStyle = '#ffb74d';
                    ctx.lineWidth = 2;
                    ctx.stroke();

                    ctx.fillStyle = colors.textMain;
                    ctx.font = '14px "Roboto Mono", monospace';
                    ctx.textAlign = 'left';
                    lines.forEach((line, i) => {
                        ctx.fillText(line, startX + 20, startY + 40 + (i * lineHeight));
                    });
                    
                    // Label
                    ctx.fillStyle = '#ef6c00';
                    ctx.font = 'bold 18px "Zen Maru Gothic", sans-serif';
                    ctx.fillText("ğŸ“¦ CSV åŸå§‹é£Ÿæ", startX, startY - 15);

                    // Shiba Face
                    ctx.font = '40px serif';
                    ctx.fillText("ğŸ•", startX + workingAreaWidth - 40, startY - 10);
                }

                // 2. Scene: Process Rows & Headers
                if (['split_lines', 'parse_headers', 'init_loop', 'process_row_1_split', 'process_row_1_map', 'process_row_1_push', 'process_row_2_split', 'finish'].includes(stepType)) {
                    
                    const isSplitAnim = stepType === 'split_lines';
                    const gap = isSplitAnim ? lerp(0, 15, t) : 15;

                    // FIX: Draw Construction Zone Background FIRST (Layer 0)
                    if (stepType === 'process_row_1_map') {
                         ctx.save();
                         ctx.globalAlpha = t;
                         const zoneY = startY + 170;
                         const zoneH = 120;
                         
                         ctx.fillStyle = 'rgba(255, 224, 178, 0.5)'; // More opaque
                         ctx.beginPath();
                         if (ctx.roundRect) {
                             ctx.roundRect(startX - 10, zoneY, workingAreaWidth + 20, zoneH, 20);
                         } else {
                             ctx.rect(startX - 10, zoneY, workingAreaWidth + 20, zoneH);
                         }
                         ctx.fill();
                         
                         ctx.strokeStyle = '#ffcc80';
                         ctx.lineWidth = 2;
                         ctx.setLineDash([5, 5]);
                         ctx.stroke();
                         ctx.setLineDash([]);
                         
                         ctx.fillStyle = '#ef6c00';
                         ctx.font = 'bold 16px "Zen Maru Gothic"';
                         ctx.fillText("ğŸ¥£ æ­£åœ¨çµ„è£ç‰©ä»¶ (Mapping)", startX + workingAreaWidth/2, zoneY - 20);
                         
                         // Cute Chef Shiba
                         ctx.font = '30px serif';
                         ctx.fillText("ğŸ‘¨â€ğŸ³", startX + workingAreaWidth + 10, zoneY + 50);

                         ctx.globalAlpha = 1;
                         ctx.restore();
                    }

                    // Loop lines (Layer 1: Text Blocks)
                    lines.forEach((line, i) => {
                        let y = startY + i * (lineHeight + gap);
                        let x = startX;
                        let w = workingAreaWidth;
                        let color = '#a1887f'; // Brown-Gray
                        let alpha = 1;

                        if (i === 0) { // Header
                            if (stepIndex >= 2) color = '#64b5f6'; // Blue
                        } else { // Data
                            if (stepIndex >= 4 && i === 1) color = '#81c784'; // Green
                            if (stepIndex >= 7 && i === 2) color = '#81c784';
                        }

                        if (stepType === 'process_row_1_map' && i !== 1 && i !== 0) alpha = 0.1;
                        if (stepType === 'process_row_1_push' && i !== 0) alpha = 0.1;

                        const isHeaderSplit = stepIndex >= 2 && i === 0;
                        const isRow1Split = stepIndex >= 4 && i === 1;
                        const isRow2Split = stepIndex >= 7 && i === 2;

                        if ((i === 0 && !isHeaderSplit) || (i === 1 && !isRow1Split) || (i === 2 && !isRow2Split) || i > 2) {
                            if (alpha > 0.05) drawBlock(line, x, y, w, lineHeight, color, alpha, null, 14);
                        } else {
                            const tokens = line.split(',');
                            tokens.forEach((token, j) => {
                                const targetX = startX + j * (blockWidth + boxGap);
                                let curX = isSplitAnim ? targetX : targetX; 
                                if ((stepType === 'parse_headers' && i === 0) || (stepType === 'process_row_1_split' && i === 1)) {
                                    curX = lerp(startX, targetX, t);
                                }

                                let tokenColor = color;
                                if (i === 0) tokenColor = `hsl(${200 + j * 10}, 80%, 65%)`; // Pastel Blues
                                if (i > 0) tokenColor = `hsl(${140 + j * 10}, 60%, 65%)`; // Pastel Greens

                                // Animation logic 
                                let curY = y;
                                let curAlpha = alpha;
                                
                                // Mapping Step (Step 5)
                                if (stepType === 'process_row_1_map' && (i === 0 || i === 1)) {
                                    const meetY = startY + 180;
                                    if (i === 0) curY = lerp(y, meetY, t);
                                    if (i === 1) curY = lerp(y, meetY + 50, t);
                                }

                                // Push Step (Step 6) - Fix for Ghosting and Snapping
                                if (stepType === 'process_row_1_push') {
                                    if (i === 1) {
                                        // Row 1: Move from Mapping Pos to Result
                                        const finalX = width - resultBoxWidth + 50;
                                        const finalY = 150;
                                        const mapY = startY + 180 + 50; // Previous Pos
                                        curX = lerp(targetX, finalX, t);
                                        curY = lerp(mapY, finalY, t);
                                        curAlpha = 1 - t; // Fade out
                                    } else if (i === 0) {
                                        // Header: Move from Mapping Pos back to Original
                                        const mapY = startY + 180;
                                        curY = lerp(mapY, y, t); // Float back up
                                    }
                                }

                                if (stepIndex > 6 && i === 1) return; // Hide row 1 after push

                                drawBlock(token, curX, curY, blockWidth, lineHeight, tokenColor, curAlpha, null, 13);
                                
                                // Mapping Connection (Cute dashed line)
                                if (stepType === 'process_row_1_map' && i === 0) {
                                    const headerBottom = curY + lineHeight;
                                    const valueTop = lerp(startY + 1 * (lineHeight + gap), startY + 180 + 50, t);
                                    
                                    if (t > 0.5) {
                                        ctx.globalAlpha = (t - 0.5) * 2;
                                        ctx.beginPath();
                                        ctx.moveTo(curX + blockWidth/2, headerBottom);
                                        ctx.lineTo(curX + blockWidth/2, valueTop);
                                        ctx.strokeStyle = '#ffa726'; // Orange
                                        ctx.lineWidth = 3;
                                        ctx.lineCap = 'round'; // Fixed typo here
                                        ctx.setLineDash([0, 8]); // Dots
                                        ctx.stroke();
                                        ctx.setLineDash([]);
                                        ctx.globalAlpha = 1;
                                    }
                                }
                            });
                        }
                    });
                }

                // 3. Scene: Result Array
                if (stepIndex >= 3) {
                    const resX = width - resultBoxWidth + 10;
                    const resY = 90;
                    const resW = resultBoxWidth - 20;
                    const resH = height - 120;
                    
                    ctx.globalAlpha = stepIndex === 3 ? t : 1;
                    drawContainer(resX, resY, resW, resH, "ğŸ± const result = [ ]");
                    
                    // Shiba guarding the result
                    ctx.font = '24px serif';
                    ctx.fillText("ğŸ•", resX + resW - 30, resY - 5);

                    ctx.fillStyle = '#795548';
                    ctx.font = 'bold 18px monospace';
                    ctx.fillText("[", resX + 15, resY + 40);
                    
                    ctx.globalAlpha = 1;

                    let currentY = resY + 60;

                    if (stepIndex >= 6) {
                        let scale = 1;
                        let alpha = 1;
                        if (stepType === 'process_row_1_push') {
                            scale = 0.8 + (0.2 * t);
                            alpha = t;
                        }
                        const row1Data = rows[0];
                        const usedH = drawJSONObject(resX + 25, currentY, row1Data, headers, alpha, scale);
                        currentY += usedH + 10;
                    }
                    
                    if (stepIndex >= 6) {
                         ctx.fillStyle = '#795548';
                         ctx.font = 'bold 18px monospace';
                         ctx.fillText("]", resX + 15, currentY);
                    }
                }
                
                // Final Scene
                if (stepType === 'finish') {
                    ctx.fillStyle = 'rgba(255, 248, 225, 0.9)'; // Light cream overlay
                    ctx.fillRect(0, 0, width, height);
                    
                    const centerY = height / 2;
                    
                    // Shiba Party
                    ctx.font = '60px serif';
                    ctx.textAlign = 'center';
                    ctx.fillText("ğŸ• ğŸ‰ ğŸ©", width/2, centerY - 140);

                    ctx.fillStyle = '#ef6c00';
                    ctx.font = 'bold 32px "Zen Maru Gothic", sans-serif';
                    ctx.fillText("è½‰æ›å®Œæˆï¼é–‹å‹•å›‰ï¼", width/2, centerY - 80);
                    
                    const startJsonY = centerY - 40;
                    const jsonX = width / 2 - 150;
                    
                    ctx.font = '16px "Roboto Mono", monospace';
                    ctx.textAlign = 'left';
                    ctx.fillStyle = '#5d4037';
                    
                    ctx.fillText("[", jsonX, startJsonY);
                    let h1 = drawJSONObject(jsonX + 20, startJsonY + 25, rows[0], headers);
                    let h2 = drawJSONObject(jsonX + 20, startJsonY + 25 + h1 + 5, rows[1], headers);
                    ctx.fillStyle = '#5d4037';
                    ctx.fillText("]", jsonX, startJsonY + 25 + h1 + 5 + h2 + 10);
                }
            };

            // --- Handlers ---
            const handleNext = () => {
                if (currentStep < STEPS.length - 1) setCurrentStep(c => c + 1);
            };

            const handlePrev = () => {
                if (currentStep > 0) setCurrentStep(c => c - 1);
            };

            const handleRestart = () => {
                setCurrentStep(0);
            };

            return (
                <div className="flex flex-col md:flex-row h-screen bg-[#fff8e1] text-[#4e342e] overflow-hidden font-sans">
                
                {/* Left Panel: Visualization Canvas */}
                <div className="flex-1 relative bg-[#fff8e1] flex flex-col">
                    <div className="p-4 border-b-2 border-[#ffe0b2] flex justify-between items-center bg-[#fff3e0]">
                        <h2 className="text-xl font-bold text-[#ef6c00] flex items-center gap-2">
                            <PawIcon size={24} className="text-[#ef6c00]" />
                            æŸ´æŸ´è¦–è¦ºåŒ–ç•«å¸ƒ
                        </h2>
                        <div className="text-sm font-bold text-[#8d6e63] bg-[#fff8e1] px-3 py-1 rounded-full border border-[#ffe0b2]">
                            Step: {currentStep + 1} / {STEPS.length} ğŸ¾
                        </div>
                    </div>
                    
                    <div ref={containerRef} className="flex-1 w-full h-full relative overflow-hidden bg-white/50">
                        <canvas 
                            ref={canvasRef}
                            width={canvasSize.width}
                            height={canvasSize.height}
                            className="block"
                        />
                        
                        {/* Legend / Overlay */}
                        <div className="absolute bottom-4 left-4 flex gap-4 text-xs bg-white/90 p-3 rounded-2xl shadow-lg border-2 border-[#ffe0b2] select-none z-10 font-bold text-[#5d4037]">
                            <div className="flex items-center gap-2"><div className="w-3 h-3 bg-[#64b5f6] rounded-full"></div> æ¨™é¡Œ (Header)</div>
                            <div className="flex items-center gap-2"><div className="w-3 h-3 bg-[#81c784] rounded-full"></div> è³‡æ–™ (Data)</div>
                            <div className="flex items-center gap-2"><div className="w-3 h-3 border-2 border-[#ef6c00] border-dashed rounded flex justify-center items-center text-[6px]"></div> ç‰©ä»¶ (Object)</div>
                        </div>
                    </div>
                </div>

                {/* Right Panel: Code & Controls */}
                <div className="w-full md:w-[450px] flex flex-col bg-[#fff3e0] border-l-4 border-[#ffcc80] shadow-xl">
                    
                    {/* Header */}
                    <div className="p-5 border-b-2 border-[#ffe0b2] bg-[#ffe0b2] z-10">
                        <h1 className="text-2xl font-bold mb-1 text-[#e65100] flex items-center gap-2">
                            <BoneIcon size={28} />
                            CSV to JSON å»šæˆ¿
                        </h1>
                        <p className="text-[#795548] text-sm font-bold">è·Ÿè‘—æŸ´æŸ´ä¸€èµ·æŠŠç”Ÿé£Ÿ (CSV) ç…®æˆä¾¿ç•¶ (JSON)ï¼</p>
                    </div>

                    {/* Code View */}
                    <div className="flex-1 overflow-auto p-4 bg-[#4a403a]">
                        <div className="font-mono text-sm leading-6 relative text-[#efebe9]">
                            {/* Line Numbers */}
                            <div className="absolute left-0 top-0 text-[#a1887f] select-none text-right pr-3 border-r border-[#6d4c41] h-full w-8 font-bold">
                                {CODE_SNIPPET.split('\n').map((_, i) => (
                                    <div key={i} style={{height: '24px'}}>{i + 1}</div>
                                ))}
                            </div>
                            
                            {/* Code Lines */}
                            <div className="pl-10">
                                {CODE_SNIPPET.split('\n').map((line, i) => {
                                    const isHighlighted = STEPS[currentStep].highlight.includes(i + 1);
                                    return (
                                        <div 
                                            key={i} 
                                            className={`whitespace-pre px-2 transition-colors duration-300 rounded-lg my-0.5 ${isHighlighted ? 'bg-[#ffcc80] text-[#bf360c] font-bold shadow-md transform scale-[1.02]' : 'text-[#d7ccc8]'}`}
                                            style={{height: '24px'}}
                                        >
                                            {line}
                                        </div>
                                    );
                                })}
                            </div>
                        </div>
                    </div>

                    {/* Footer: Controls & Description */}
                    <div className="border-t-2 border-[#ffe0b2] bg-[#fff8e1] p-5 shadow-[0_-5px_15px_rgba(0,0,0,0.05)] z-10">
                        {/* Step Description */}
                        <div className="mb-4 min-h-[90px] bg-white p-4 rounded-2xl border-2 border-[#ffe0b2] relative">
                            {/* Speech Bubble Triangle */}
                            <div className="absolute top-[-12px] left-6 w-0 h-0 border-l-[10px] border-l-transparent border-r-[10px] border-r-transparent border-b-[12px] border-b-[#ffe0b2]"></div>
                            <div className="absolute top-[-9px] left-6 w-0 h-0 border-l-[10px] border-l-transparent border-r-[10px] border-r-transparent border-b-[12px] border-b-white"></div>
                            
                            <h3 className="font-bold text-[#e65100] mb-2 flex items-center gap-2 text-lg">
                                <span className="text-xl">ğŸ•</span>
                                Step {currentStep + 1}: {STEPS[currentStep].title}
                            </h3>
                            <p className="text-[#5d4037] text-sm leading-relaxed font-medium">
                                {STEPS[currentStep].desc}
                            </p>
                        </div>

                        {/* Progress Bar */}
                        <div className="h-3 bg-[#ffe0b2] w-full mb-5 rounded-full overflow-hidden border border-[#ffcc80]">
                            <div 
                                className="h-full bg-[#ef6c00] transition-all duration-300 ease-out rounded-full relative" 
                                style={{width: `${((currentStep + 1) / STEPS.length) * 100}%`}}
                            >
                                <div className="absolute right-0 top-0 bottom-0 w-2 bg-white/30 animate-pulse"></div>
                            </div>
                        </div>

                        {/* Buttons */}
                        <div className="flex justify-between gap-3">
                            <button 
                                onClick={handleRestart}
                                className="p-3 text-[#8d6e63] hover:text-[#e65100] hover:bg-[#ffe0b2] rounded-full transition-all border-2 border-transparent hover:border-[#ffcc80]"
                                title="é‡æ–°é–‹å§‹"
                            >
                                <RotateCcw size={22} />
                            </button>
                            
                            <div className="flex gap-3">
                                <button 
                                    onClick={handlePrev}
                                    disabled={currentStep === 0}
                                    className="flex items-center gap-2 px-5 py-2.5 bg-[#8d6e63] text-white rounded-full hover:bg-[#6d4c41] disabled:opacity-50 disabled:cursor-not-allowed transition-all font-bold shadow-md active:translate-y-0.5"
                                >
                                    <ChevronLeft size={18} /> ä¸Šä¸€æ­¥
                                </button>
                                <button 
                                    onClick={handleNext}
                                    disabled={currentStep === STEPS.length - 1}
                                    className="flex items-center gap-2 px-8 py-2.5 bg-[#ef6c00] text-white rounded-full hover:bg-[#e65100] disabled:opacity-50 disabled:cursor-not-allowed transition-all shadow-lg shadow-orange-200 active:translate-y-0.5 font-bold text-lg"
                                >
                                    {currentStep === STEPS.length - 1 ? 'å®Œæˆï¼' : 'ä¸‹ä¸€æ­¥'} <ChevronRight size={20} />
                                </button>
                            </div>
                        </div>
                    </div>

                </div>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<CSVVisualizer />);
    </script>
</body>
</html>